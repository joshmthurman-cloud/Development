import React, { useEffect, useMemo, useRef, useState } from "react";

const LS_KEYS = {
  user: "ctb_user",
  counter: "ctb_refid_counter",
  logs: "ctb_logs",
  settings: "ctb_settings",
};

function saveJSON(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}
function loadJSON(key, fallback) {
  try {
    const v = localStorage.getItem(key);
    return v ? JSON.parse(v) : fallback;
  } catch {
    return fallback;
  }
}

const TRANS_TYPES = ["Auth", "Capture", "Sale", "ReferentialSale", "Reversal", "Return", "Settle"];
const PAYMENT_TYPES = ["Credit", "Debit"];
const YES_NO = ["No", "Yes"];

export default function App() {
  const [user, setUser] = useState(() => loadJSON(LS_KEYS.user, null));
  const [firstName, setFirstName] = useState("");
  const [settings, setSettings] = useState(() =>
    loadJSON(LS_KEYS.settings, {
      baseUrl: "https://spinpos.net:443/spin/cgi.html?TerminalTransaction=",
      useRegisterIdSpelling: "RegisterId",
      defaultPrintReceipt: "No",
      defaultSigCapture: "No",
      defaultAuthKey: "",
      defaultRegisterId: "",
      taxMode: "rate", // 'rate' | 'amount'
      taxRatePct: 10,
      taxAmountOverride: "", // when taxMode === 'amount'
      localTaxFlag: "TaxProvided",
      executeBehavior: "iframe", // 'iframe' | 'newtab' | 'both'
      donePhrase: "Done", // same-origin only heuristic
      relayCaptureUrl: "", // optional server relay
      relayOnLoaded: true,
      relayOnExecute: true,
    })
  );

  const [counter, setCounter] = useState(() => {
    const v = Number(localStorage.getItem(LS_KEYS.counter));
    return Number.isFinite(v) && v >= 0 ? v : 1;
  });
  const [logs, setLogs] = useState(() => loadJSON(LS_KEYS.logs, []));

  // Form state
  const [transType, setTransType] = useState("Auth");
  const [paymentType, setPaymentType] = useState("Credit");
  const [authKey, setAuthKey] = useState("");
  const [registerId, setRegisterId] = useState("");
  const [amount, setAmount] = useState("");
  const [invNum, setInvNum] = useState("");
  const [custRef, setCustRef] = useState("");
  const [destZipCode, setDestZipCode] = useState("");
  const [authCode, setAuthCode] = useState("");
  const [address, setAddress] = useState("");
  const [zip, setZip] = useState("");
  const [printReceipt, setPrintReceipt] = useState("");
  const [sigCapture, setSigCapture] = useState("");
  const [reversalType, setReversalType] = useState("Full");
  const [token, setToken] = useState("");
  const [expiry, setExpiry] = useState("");
  const [refIdInput, setRefIdInput] = useState(""); // manual MFUKEY for Capture/Reversal only

  // init defaults from settings once
  useEffect(() => {
    setPrintReceipt(settings.defaultPrintReceipt || "No");
    setSigCapture(settings.defaultSigCapture || "No");
    if (settings.defaultAuthKey) setAuthKey(settings.defaultAuthKey);
    if (settings.defaultRegisterId) setRegisterId(settings.defaultRegisterId);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const [iframeUrl, setIframeUrl] = useState("");
  const iframeRef = useRef(null);
  const pollRef = useRef(null);
  const relayAbortRef = useRef(null);
  const clerkId = user?.firstName || "";
  const refIdAuto = counter;
  // Return uses new (auto) RefId; Capture/Reversal allow manual previous RefId
  const refIdEffective =
    ["Capture", "Reversal"].includes(transType) && refIdInput.trim() !== ""
      ? refIdInput
      : refIdAuto;
  const [currentLogId, setCurrentLogId] = useState(null);

  // 1s ticker for UI countdowns
  const [nowTs, setNowTs] = useState(Date.now());
  useEffect(() => {
    const iv = setInterval(() => setNowTs(Date.now()), 1000);
    return () => clearInterval(iv);
  }, []);

  // Helpers
  const formatAmount = (val) => {
    if (val === null || val === undefined || String(val).trim() === "") return "0.00";
    const s = String(val).trim();
    if (!s.includes(".")) return s + ".00";
    const [w, f = ""] = s.split(".");
    if (f.length === 0) return `${w}.00`;
    if (f.length === 1) return `${w}.${f}0`;
    return s;
  };

  const taxAmount = useMemo(() => {
    if (settings.taxMode === "amount" && String(settings.taxAmountOverride || "").trim() !== "") {
      const fixed = Number(settings.taxAmountOverride);
      return Number.isFinite(fixed) ? fixed.toFixed(2) : "0.00";
    }
    const amt = Number(amount || 0);
    if (!Number.isFinite(amt)) return "0.00";
    const rate = Number(settings.taxRatePct) / 100;
    return amt > 0 ? (amt * rate).toFixed(2) : "0.00";
  }, [amount, settings.taxMode, settings.taxRatePct, settings.taxAmountOverride]);

  const cardData = useMemo(() => {
    const a = (address || "").trim();
    const z = (zip || "").trim();
    if (!a && !z) return "";
    return `${a}${a && z ? "," : ""}${z}`;
  }, [address, zip]);

  // persist
  useEffect(() => saveJSON(LS_KEYS.settings, settings), [settings]);
  useEffect(() => saveJSON(LS_KEYS.logs, logs), [logs]);
  useEffect(() => localStorage.setItem(LS_KEYS.counter, String(counter)), [counter]);

  // auth
  const handleLogin = () => {
    const fn = firstName.trim();
    if (!fn) return alert("Please enter your first name.");
    const next = { firstName: fn };
    setUser(next);
    saveJSON(LS_KEYS.user, next);
  };
  const handleLogout = () => {
    setUser(null);
    localStorage.removeItem(LS_KEYS.user);
  };

  // Required fields map (reversal now REQUIRES Amount)
  const requiredFor = useMemo(
    () => ({
      Auth: ["PaymentType", "TransType", "Amount", "AuthKey", settings.useRegisterIdSpelling, "RefId"],
      $1
      ReferentialSale: [$2],
      Capture: [
        "PaymentType",
        "TransType",
        "Amount",
        "AuthKey",
        settings.useRegisterIdSpelling,
        "RefId",
        "AuthCode",
        "CustRef",
      ],
      Return: [
        "TransType",
        "Amount",
        "AuthKey",
        settings.useRegisterIdSpelling,
        "RefId",
        "PaymentType",
        "Token",
        "Expiry",
        "AuthCode",
      ],
      Reversal: [
        "TransType",
        "Amount", // now required
        "AuthKey",
        settings.useRegisterIdSpelling,
        "RefId",
        "PaymentType",
      ],
      Settle: ["TransType", "AuthKey", settings.useRegisterIdSpelling],
    }),
    [settings.useRegisterIdSpelling]
  );

  const valuesMap = useMemo(
    () => ({
      PaymentType: paymentType,
      TransType: transType,
      AmountRaw: amount,
      Amount: formatAmount(amount),
      AuthKey: authKey,
      [settings.useRegisterIdSpelling]: registerId,
      RefId: ["Capture", "Reversal"].includes(transType) ? refIdInput : String(refIdAuto),
      InvNum: invNum,
      Token: token,
      Expiry: expiry,
      CustRef: custRef,
      AuthCode: authCode,
    }),
    [
      paymentType,
      transType,
      amount,
      authKey,
      registerId,
      refIdInput,
      refIdAuto,
      invNum,
      token,
      expiry,
      custRef,
      authCode,
      settings.useRegisterIdSpelling,
    ]
  );

  const missingRequired = useMemo(() => {
    const req = requiredFor[transType] || [];
    return req.filter((k) => {
      if (k === "Amount") return String(valuesMap.AmountRaw || "").trim() === ""; // use raw input
      if (k === settings.useRegisterIdSpelling) return String(registerId || "").trim() === "";
      if (k === "RefId") {
        const v = ["Capture", "Reversal"].includes(transType) ? refIdInput : String(refIdAuto);
        return String(v || "").trim() === "";
      }
      return !valuesMap[k] || String(valuesMap[k]).trim() === "";
    });
  }, [requiredFor, transType, valuesMap, registerId, refIdInput, refIdAuto, settings.useRegisterIdSpelling]);

  const isMissing = (field) => missingRequired.includes(field);

  // Allowed tags per type (controls XML preview/output)
  const allowedTags = useMemo(() => {
    const keyReg = settings.useRegisterIdSpelling;
    switch (transType) {
      case "Settle":
        return new Set(["TransType", "AuthKey", keyReg]);
      case "Auth":
      case "Sale":
        return new Set([
          "PaymentType",
          "TransType",
          "Amount",
          "AuthKey",
          keyReg,
          "RefId",
          "InvNum",
          "ClerkId",
          "PrintReceipt",
          "SigCapture",
          "CardData",
          "TaxAmount",
          "LocalTaxFlag",
          "CustRef",
          "DestZipCode",
        ]);
      case "ReferentialSale":
        return new Set([
          "PaymentType","TransType","Amount","AuthKey", keyReg, "RefId","InvNum","ClerkId","PrintReceipt","SigCapture","CardData","TaxAmount","LocalTaxFlag","CustRef","DestZipCode","Token","Expiry"
        ]);
      case "Capture":
        return new Set([
          "PaymentType",
          "TransType",
          "Amount",
          "AuthKey",
          keyReg,
          "RefId",
          "InvNum",
          "ClerkId",
          "CustRef",
          "DestZipCode",
          "TaxAmount",
          "LocalTaxFlag",
          "PrintReceipt",
          "SigCapture",
          "AuthCode",
        ]);
      case "Return":
        return new Set([
          "TransType",
          "Amount",
          "AuthKey",
          keyReg,
          "RefId",
          "PaymentType",
          "InvNum", // optional
          "Token",
          "Expiry",
          "ClerkId",
          "AuthCode",
          "PrintReceipt", // always include, forced No
          "SigCapture",  // always include, forced No
        ]);
      case "Reversal":
        return new Set([
          "TransType",
          "Amount", // now included
          "AuthKey",
          keyReg,
          "RefId",
          "PaymentType",
          "ReversalType",
          "ClerkId",
          "PrintReceipt", // always include, forced No
          "SigCapture",  // always include, forced No
        ]);
      default:
        return new Set();
    }
  }, [transType, settings.useRegisterIdSpelling]);

  // Build XML
  const buildXml = () => {
    const keyReg = settings.useRegisterIdSpelling;
    const parts = [];
    const pushTag = (name, value) => {
      if (!allowedTags.has(name)) return;
      if (value === undefined || value === null) return;
      if (String(value).trim() === "") return;
      parts.push(`<${name}>${escapeXml(String(value))}</${name}>`);
    };

    const formattedAmount = formatAmount(amount);
    const refIdOut = ["Capture", "Reversal"].includes(transType) ? refIdInput : String(refIdAuto);

    pushTag("PaymentType", paymentType);
    pushTag("TransType", transType === "ReferentialSale" ? "Sale" : transType);
    pushTag("Amount", formattedAmount);
    pushTag("AuthKey", authKey);
    pushTag(keyReg, registerId);
    pushTag("RefId", refIdOut);
    pushTag("InvNum", invNum);
    pushTag("ClerkId", clerkId);

    // Properties-only fields (still included in XML where allowed)
    const forceNo = ["Capture", "Return", "Reversal"].includes(transType) ? "No" : printReceipt;
    const forceNoSig = ["Capture", "Return", "Reversal"].includes(transType) ? "No" : sigCapture;
    pushTag("PrintReceipt", forceNo);
    pushTag("SigCapture", forceNoSig);
    if (cardData) pushTag("CardData", cardData);
    pushTag("TaxAmount", taxAmount);
    pushTag("LocalTaxFlag", settings.localTaxFlag);

    // Optional/conditional fields
    pushTag("CustRef", custRef);
    pushTag("DestZipCode", destZipCode);
    if (transType !== "Reversal") {
      pushTag("Token", token);
      pushTag("Expiry", expiry);
    }
    pushTag("AuthCode", authCode);
    if (transType === "Reversal") pushTag("ReversalType", reversalType);

    return `<request>${parts.join("")}</request>`;
  };

  // Show/hide fields in Build section (not XML)
  const shouldShowField = (field) => {
    if (transType === "Settle") {
      return ["TransType", "AuthKey", settings.useRegisterIdSpelling].includes(field);
    }
    if (transType === "Auth" && ["AuthCode", "Token", "Expiry"].includes(field)) return false;
    if ((transType === "Capture" || transType === "Reversal") && ["Token", "Expiry"].includes(field)) return false;
    if (transType === "Sale" && ["AuthCode", "Token", "Expiry"].includes(field)) return false;
    // Hide from Build: controlled in Properties
    if (["PrintReceipt", "SigCapture", "CardData", "TaxAmount", "LocalTaxFlag", "ClerkId"].includes(field)) return false;
    return true;
  };

  // Clear selected fields when switching TransType (only if visible for the new type)
  const prevTransTypeRef = useRef(transType);
  useEffect(() => {
    if (prevTransTypeRef.current !== transType) {
      const clearIfVisible = (field, clear) => {
        try {
          if (shouldShowField(field)) clear();
        } catch {}
      };
      clearIfVisible("Amount", () => setAmount(""));
      clearIfVisible("Address", () => setAddress(""));
      clearIfVisible("Zip", () => setZip(""));
      clearIfVisible("CustRef", () => setCustRef(""));
      clearIfVisible("DestZipCode", () => setDestZipCode(""));
      clearIfVisible("AuthCode", () => setAuthCode(""));
      clearIfVisible("Token", () => setToken(""));
      clearIfVisible("Expiry", () => setExpiry(""));
      prevTransTypeRef.current = transType;
    }
  }, [transType]);

  const buildUrl = () => settings.baseUrl + encodeURIComponent(buildXml());
  const canExecute = user && missingRequired.length === 0;

  const execute = () => {
    if (!user) return alert("Please log in first.");
    if (missingRequired.length) {
      alert("Missing required fields: " + missingRequired.join(", "));
      return;
    }
    const url = buildUrl();
    const awaitUntilMs = Date.now() + 60_000; // wait up to 60s
    const refOut = ["Capture", "Reversal"].includes(transType) ? refIdInput : refIdAuto;
    const logEntry = {
      id: `${Date.now()}_${refOut}`,
      timestamp: new Date().toISOString(),
      user: clerkId,
      transType,
      amount: formatAmount(amount),
      refId: refOut,
      requestXml: buildXml(),
      requestUrl: url,
      responseCaptured: null,
      status: "listening",
      awaitUntilMs,
    };
    setLogs((prev) => [logEntry, ...prev]);
    setCurrentLogId(logEntry.id);
    setCounter((c) => c + 1);

    // Optional relay attempts (harmless if not configured)
    if (settings.relayOnExecute && settings.relayCaptureUrl) {
      setTimeout(() => attemptRelayCapture(logEntry.id, { mode: "get_result" }), 200);
    }

    setTimeout(() => {
      setLogs((prev) =>
        prev.map((l) => (l.id === logEntry.id && l.status === "listening" ? { ...l, status: "timeout" } : l))
      );
    }, 60_000);

    if (settings.executeBehavior === "newtab") {
      window.open(url, "_blank", "noopener");
    } else if (settings.executeBehavior === "both") {
      setIframeUrl(url);
      window.open(url, "_blank", "noopener");
    } else {
      setIframeUrl(url);
    }
  };

  // Try to auto-capture for same-origin pages (not spinpos)
  const handleIframeLoad = () => {
    if (!currentLogId) return;
    if (pollRef.current) {
      clearInterval(pollRef.current);
      pollRef.current = null;
    }

    const start = Date.now();
    const maxMs = 60_000;

    const tryRead = () => {
      let text = "";
      try {
        const doc = iframeRef.current?.contentDocument || iframeRef.current?.contentWindow?.document;
        text = (doc?.body?.innerText || doc?.documentElement?.innerText || "").trim();
      } catch (e) {
        // Cross-origin: can't read. Mark loaded and stop.
        setLogs((prev) =>
          prev.map((l) => (l.id === currentLogId ? { ...l, status: "loaded", awaitUntilMs: undefined } : l))
        );
        clearInterval(pollRef.current);
        pollRef.current = null;
        if (settings.relayOnLoaded && settings.relayCaptureUrl) {
          setTimeout(() => attemptRelayCapture(currentLogId), 1000);
        }
        return;
      }

      if (text) {
        const hasDone = settings.donePhrase ? text.includes(settings.donePhrase) : true;
        if (hasDone || text.length > 0) {
          setLogs((prev) =>
            prev.map((l) =>
              l.id === currentLogId
                ? { ...l, status: "captured", responseCaptured: text, awaitUntilMs: undefined }
                : l
            )
          );
          clearInterval(pollRef.current);
          pollRef.current = null;
          return;
        }
      }

      if (Date.now() - start > maxMs) {
        setLogs((prev) =>
          prev.map((l) => (l.id === currentLogId ? { ...l, status: "timeout", awaitUntilMs: undefined } : l))
        );
        clearInterval(pollRef.current);
        pollRef.current = null;
      }
    };

    tryRead();
    if (!pollRef.current) pollRef.current = setInterval(tryRead, 500);
  };

  // Optional relay to fetch response server-side (no-op if not set)
  const attemptRelayCapture = async (logId, opts = {}) => {
    try {
      const log = logs.find((l) => l.id === logId);
      if (!log) return;
      const controller = new AbortController();
      relayAbortRef.current = controller;
      const resp = await fetch(settings.relayCaptureUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          url: log.requestUrl,
          refId: log.refId,
          transType: log.transType,
          xml: log.requestXml,
          mode: opts.mode || "auto",
        }),
        signal: controller.signal,
      });
      const text = await resp.text();
      if (resp.ok && text) {
        setLogs((prev) =>
          prev.map((l) =>
            l.id === logId ? { ...l, status: "captured", responseCaptured: text, awaitUntilMs: undefined } : l
          )
        );
      } else {
        setLogs((prev) =>
          prev.map((l) =>
            l.id === logId ? { ...l, relayError: `Relay error ${resp.status}`, awaitUntilMs: undefined } : l
          )
        );
      }
    } catch (e) {
      setLogs((prev) =>
        prev.map((l) => (l.id === logId ? { ...l, relayError: e?.message || String(e), awaitUntilMs: undefined } : l))
      );
    } finally {
      relayAbortRef.current = null;
    }
  };

  // Manual capture
  const [captureText, setCaptureText] = useState("");
  const attachResponseToMostRecent = () => {
    const latestId = logs[0]?.id;
    if (!latestId) return alert("No logs available to attach.");
    if (!captureText.trim()) return alert("Paste the response text first.");
    setLogs((prev) =>
      prev.map((l, i) => (i === 0 ? { ...l, responseCaptured: captureText.trim(), status: "captured", awaitUntilMs: undefined } : l))
    );
    setCaptureText("");
  };

  // Export / Save / Clear
  const logsToCSV = (list) => {
    const rows = [
      ["timestamp", "user", "transType", "amount", "refId", "requestUrl", "requestXml", "responseCaptured", "status"],
      ...list.map((l) => [
        l.timestamp,
        l.user,
        l.transType,
        l.amount,
        String(l.refId),
        l.requestUrl,
        l.requestXml,
        l.responseCaptured || "",
        l.status || "",
      ]),
    ];
    return rows.map((r) => r.map(csvEscape).join(",")).join("
");
  };

  const exportLogs = () => {
    const csv = logsToCSV(logs);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `transaction_logs_${new Date().toISOString().slice(0, 19)}.csv`;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  };

  const saveLogsToFolder = async () => {
    try {
      if (!window.showDirectoryPicker) {
        alert("Your browser doesn't support selecting folders. Use Export CSV instead.");
        return;
      }
      const rootDir = await window.showDirectoryPicker();
      const logsDir = await rootDir.getDirectoryHandle("Logs", { create: true });
      const ymd = new Date().toISOString().slice(0, 10).replace(/-/g, "");
      let n = 1;
      let name;
      while (true) {
        name = `${ymd}${n}.csv`;
        try {
          await logsDir.getFileHandle(name, { create: false });
          n++;
        } catch (err) {
          if (err?.name === "NotFoundError") break;
          else throw err;
        }
      }
      const fh = await logsDir.getFileHandle(name, { create: true });
      const writable = await fh.createWritable();
      await writable.write(logsToCSV(logs));
      await writable.close();
      alert(`Saved logs to Logs/${name}`);
    } catch (e) {
      console.error(e);
      alert("Could not save logs: " + (e?.message || e));
    }
  };

  const clearLogs = () => {
    if (!confirm("Clear all logs?")) return;
    setLogs([]);
    try {
      localStorage.removeItem(LS_KEYS.logs);
    } catch {}
  };

  const missingSummary = missingRequired.length ? `Missing required: ${missingRequired.join(", ")}` : "";

  return (
    <div className="min-h-screen bg-slate-50 text-slate-900">
      <div className="max-w-6xl mx-auto p-6 space-y-6">
        <header className="flex items-center justify-between">
          <h1 className="text-2xl font-semibold">Curbstone Transaction Builder</h1>
          <div className="flex items-center gap-3">
            {user ? (
              <>
                <span className="text-sm">
                  Signed in as <strong>{user.firstName}</strong>
                </span>
                <button className="px-3 py-1 rounded-xl bg-slate-200 hover:bg-slate-300" onClick={handleLogout}>
                  Sign out
                </button>
              </>
            ) : (
              <div className="flex items-center gap-2">
                <input
                  className="px-3 py-2 rounded-xl border w-40"
                  placeholder="First name"
                  value={firstName}
                  onChange={(e) => setFirstName(e.target.value)}
                />
                <button className="px-4 py-2 rounded-xl bg-slate-900 text-white hover:opacity-90" onClick={handleLogin}>
                  Create account / Sign in
                </button>
              </div>
            )}
          </div>
        </header>

        {/* Properties / Defaults */}
        <details className="bg-white rounded-2xl shadow p-4" open>
          <summary className="cursor-pointer font-medium">Properties & Defaults</summary>
          <div className="grid md:grid-cols-3 gap-4 mt-4">
            <label className="flex flex-col gap-1">
              <span className="text-sm">Default AuthKey</span>
              <input
                className="px-3 py-2 rounded-xl border"
                value={settings.defaultAuthKey}
                onChange={(e) => setSettings({ ...settings, defaultAuthKey: e.target.value })}
              />
            </label>
            <label className="flex flex-col gap-1">
              <span className="text-sm">Default {settings.useRegisterIdSpelling}</span>
              <input
                className="px-3 py-2 rounded-xl border"
                value={settings.defaultRegisterId}
                onChange={(e) => setSettings({ ...settings, defaultRegisterId: e.target.value })}
              />
            </label>

            {/* Only here: PrintReceipt, SigCapture, CardData/Tax/Flag previews */}
            <label className="flex flex-col gap-1">
              <span className="text-sm">PrintReceipt</span>
              <select className="px-3 py-2 rounded-xl border" value={printReceipt} onChange={(e) => setPrintReceipt(e.target.value)}>
                {YES_NO.map((v) => (
                  <option key={v} value={v}>
                    {v}
                  </option>
                ))}
              </select>
            </label>
            <label className="flex flex-col gap-1">
              <span className="text-sm">SigCapture</span>
              <select className="px-3 py-2 rounded-xl border" value={sigCapture} onChange={(e) => setSigCapture(e.target.value)}>
                {YES_NO.map((v) => (
                  <option key={v} value={v}>
                    {v}
                  </option>
                ))}
              </select>
            </label>

            {/* Tax controls */}
            <div className="flex flex-col gap-1">
              <span className="text-sm">Tax mode</span>
              <div className="flex gap-3 items-center">
                <label className="flex items-center gap-2 text-sm">
                  <input
                    type="radio"
                    name="taxmode"
                    checked={settings.taxMode === "rate"}
                    onChange={() => setSettings({ ...settings, taxMode: "rate" })}
                  />{" "}
                  Rate (%)
                </label>
                <label className="flex items-center gap-2 text-sm">
                  <input
                    type="radio"
                    name="taxmode"
                    checked={settings.taxMode === "amount"}
                    onChange={() => setSettings({ ...settings, taxMode: "amount" })}
                  />{" "}
                  Amount
                </label>
              </div>
            </div>
            {settings.taxMode === "rate" ? (
              <label className="flex flex-col gap-1">
                <span className="text-sm">Tax rate (%)</span>
                <input
                  type="number"
                  className="px-3 py-2 rounded-xl border"
                  value={settings.taxRatePct}
                  onChange={(e) => setSettings({ ...settings, taxRatePct: Number(e.target.value || 0) })}
                />
              </label>
            ) : (
              <label className="flex flex-col gap-1">
                <span className="text-sm">Tax amount (&lt;TaxAmount&gt;)</span>
                <input
                  type="number"
                  className="px-3 py-2 rounded-xl border"
                  value={settings.taxAmountOverride}
                  onChange={(e) => setSettings({ ...settings, taxAmountOverride: e.target.value })}
                />
              </label>
            )}

            <label className="flex flex-col gap-1">
              <span className="text-sm">LocalTaxFlag</span>
              <input
                className="px-3 py-2 rounded-xl border"
                value={settings.localTaxFlag}
                onChange={(e) => setSettings({ ...settings, localTaxFlag: e.target.value })}
              />
            </label>

            {/* Computed previews */}
            <LabeledReadOnly label="CardData (computed)" value={cardData || ""} />
            <LabeledReadOnly label="TaxAmount (computed)" value={taxAmount} />

            <label className="flex flex-col gap-1">
              <span className="text-sm">Execute behavior</span>
              <select
                className="px-3 py-2 rounded-xl border"
                value={settings.executeBehavior}
                onChange={(e) => setSettings({ ...settings, executeBehavior: e.target.value })}
              >
                <option value="iframe">Load in iframe</option>
                <option value="newtab">Open new tab</option>
                <option value="both">Both (reliable)</option>
              </select>
            </label>

            {/* Relay capture settings (optional) */}
            <label className="flex flex-col gap-1">
              <span className="text-sm">Response Relay URL</span>
              <input
                className="px-3 py-2 rounded-xl border"
                placeholder="https://your-worker.workers.dev"
                value={settings.relayCaptureUrl}
                onChange={(e) => setSettings({ ...settings, relayCaptureUrl: e.target.value })}
              />
            </label>
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={!!settings.relayOnLoaded}
                onChange={(e) => setSettings({ ...settings, relayOnLoaded: e.target.checked })}
              />
              <span className="text-sm">Auto-capture via relay when cross-origin page loads</span>
            </label>
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={!!settings.relayOnExecute}
                onChange={(e) => setSettings({ ...settings, relayOnExecute: e.target.checked })}
              />
              <span className="text-sm">Kick off relay immediately at Execute</span>
            </label>
          </div>
        </details>

        {/* Build Transaction (reordered) */}
        <section className="bg-white rounded-2xl shadow p-4 space-y-4">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-medium">Build Transaction</h2>
            {missingRequired.length > 0 && (
              <div className="text-xs text-red-600" title={missingSummary}>
                {missingSummary}
              </div>
            )}
          </div>

          <div className="grid md:grid-cols-3 gap-4">
            {/* Row 1 */}
            <LabeledSelect
              label="TransType"
              value={transType}
              onChange={setTransType}
              options={TRANS_TYPES}
              required={true}
              missing={isMissing("TransType")}
            />
            {shouldShowField("PaymentType") && (
              <LabeledSelect
                label="PaymentType"
                value={paymentType}
                onChange={setPaymentType}
                options={PAYMENT_TYPES}
                required={requiredFor[transType]?.includes("PaymentType")}
                missing={isMissing("PaymentType")}
              />
            )}
            {shouldShowField("InvNum") && (
              <LabeledInput
                label="Invoice Number (InvNum)"
                value={invNum}
                onChange={setInvNum}
                placeholder={
                  requiredFor[transType]?.includes("InvNum") && isMissing("InvNum") ? "Required" : undefined
                }
                missing={isMissing("InvNum")}
              />
            )}

            {/* Row 2 */}
            {shouldShowField("Amount") && (
              <LabeledInput
                label="Amount"
                value={amount}
                onChange={setAmount}
                type="number"
                placeholder={isMissing("Amount") ? "Required" : "e.g., 1.00"}
                missing={isMissing("Amount")}
                disabled={false}
              />
            )}
            {shouldShowField("Address") && (
              <LabeledInput label="Address" value={address} onChange={setAddress} placeholder="Optional" />
            )}
            {shouldShowField("Zip") && <LabeledInput label="Zip" value={zip} onChange={setZip} placeholder="Optional" />}

            {/* Row 3 */}
            {shouldShowField("CustRef") && (
              <LabeledInput
                label="Customer Number (CustRef)"
                value={custRef}
                onChange={setCustRef}
                placeholder={requiredFor[transType]?.includes("CustRef") && isMissing("CustRef") ? "Required" : "Optional"}
                required={requiredFor[transType]?.includes("CustRef")}
                missing={isMissing("CustRef")}
              />
            )}
            {shouldShowField("DestZipCode") && (
              <LabeledInput
                label="Destination Zip (DestZipCode)"
                value={destZipCode}
                onChange={setDestZipCode}
                placeholder="Optional"
              />
            )}
            {shouldShowField("RefId") &&
              (["Capture", "Reversal"].includes(transType) ? (
                <LabeledInput
                  label="MFUKEY (RefId)"
                  value={refIdInput}
                  onChange={setRefIdInput}
                  placeholder={isMissing("RefId") ? "Required" : undefined}
                  missing={isMissing("RefId")}
                />
              ) : (
                <LabeledReadOnly label="MFUKEY (RefId)" value={String(refIdAuto)} />
              ))}

            {/* Row 4 */}
            {shouldShowField("AuthKey") && (
              <LabeledInput
                label="AuthKey"
                value={authKey}
                onChange={setAuthKey}
                placeholder={isMissing("AuthKey") ? "Required" : undefined}
                missing={isMissing("AuthKey")}
              />
            )}
            {shouldShowField(settings.useRegisterIdSpelling) && (
              <LabeledInput
                label={settings.useRegisterIdSpelling}
                value={registerId}
                onChange={setRegisterId}
                placeholder={isMissing(settings.useRegisterIdSpelling) ? "Required" : undefined}
                missing={isMissing(settings.useRegisterIdSpelling)}
              />
            )}

            {/* Optional/conditional */}
            {shouldShowField("AuthCode") && (
              <LabeledInput
                label="AuthCode"
                value={authCode}
                onChange={setAuthCode}
                placeholder={
                  requiredFor[transType]?.includes("AuthCode") && isMissing("AuthCode") ? "Required" : "Optional"
                }
                required={requiredFor[transType]?.includes("AuthCode")}
                missing={isMissing("AuthCode")}
              />
            )}
            {shouldShowField("Token") && (
              <LabeledInput
                label="Token"
                value={token}
                onChange={setToken}
                placeholder={requiredFor[transType]?.includes("Token") && isMissing("Token") ? "Required" : "Optional"}
                missing={isMissing("Token")}
              />
            )}
            {shouldShowField("Expiry") && (
              <LabeledInput
                label="Expiry"
                value={expiry}
                onChange={setExpiry}
                placeholder={requiredFor[transType]?.includes("Expiry") && isMissing("Expiry") ? "Required (MMYY)" : "MMYY"}
                missing={isMissing("Expiry")}
              />
            )}
          </div>

          <div className="bg-slate-50 rounded-xl p-3 text-xs font-mono overflow-auto border">
            <div className="text-slate-500 mb-1">XML preview</div>
            <pre className="whitespace-pre-wrap">{buildXml()}</pre>
          </div>

          <div className="flex items-center gap-3">
            <button
              onClick={execute}
              disabled={!canExecute}
              title={missingSummary}
              className={`px-4 py-2 rounded-2xl text-white hover:opacity-95 ${
                canExecute ? "bg-emerald-600" : "bg-slate-400 cursor-not-allowed"
              }`}
            >Execute</button>
            <a className="px-4 py-2 rounded-2xl bg-slate-900 text-white hover:opacity-95" href={buildUrl()} target="_blank" rel="noreferrer">
              Open in new tab
            </a>
          </div>
        </section>

        {/* iFrame Result */}
        <section className="bg-white rounded-2xl shadow p-4 space-y-3">
          <h2 className="text-lg font-medium">Gateway Response (iframe)</h2>
          {iframeUrl ? (
            <iframe ref={iframeRef} title="gateway" src={iframeUrl} onLoad={handleIframeLoad} className="w-full h-[420px] rounded-xl border" />
          ) : (
            <div className="text-sm text-slate-500">Run a transaction to load the response here.</div>
          )}

          <details className="bg-slate-50 rounded-xl p-3 border">
            <summary className="cursor-pointer text-sm font-medium">Response Capture (workaround)</summary>
            <p className="text-sm mt-2">
              If the gateway page is cross-origin, browsers block reading it. Paste your response here and click Attach to save to the latest log.
            </p>
            <textarea
              className="mt-2 w-full h-28 rounded-xl border p-2 text-sm font-mono"
              placeholder="Paste raw response or key fields here"
              value={captureText}
              onChange={(e) => setCaptureText(e.target.value)}
            />
            <div className="mt-2">
              <button onClick={attachResponseToMostRecent} className="px-3 py-2 rounded-xl bg-slate-200 hover:bg-slate-300">
                Attach to most recent log
              </button>
            </div>
          </details>
        </section>

        {/* Logs */}
        <section className="bg-white rounded-2xl shadow p-4 space-y-3">
          <div className="flex items-center justify-between">
            <h2 className="text-lg font-medium">Logs</h2>
            <div className="flex gap-2">
              <button onClick={exportLogs} className="px-3 py-2 rounded-xl bg-slate-200 hover:bg-slate-300">
                Export CSV
              </button>
              <button onClick={saveLogsToFolder} className="px-3 py-2 rounded-xl bg-slate-200 hover:bg-slate-300">
                Save logs to folder
              </button>
              <button onClick={clearLogs} className="px-3 py-2 rounded-xl bg-rose-100 text-rose-700 hover:bg-rose-200">
                Clear logs
              </button>
            </div>
          </div>
          {logs.length === 0 ? (
            <div className="text-sm text-slate-500">No logs yet.</div>
          ) : (
            <div className="overflow-auto border rounded-xl">
              <table className="w-full text-sm">
                <thead className="bg-slate-50">
                  <tr>
                    <Th>Time</Th>
                    <Th>User</Th>
                    <Th>Type</Th>
                    <Th>Amount</Th>
                    <Th>RefId</Th>
                    <Th>Request URL</Th>
                    <Th>Response (captured / status)</Th>
                  </tr>
                </thead>
                <tbody>
                  {logs.map((l) => {
                    const remaining =
                      l.awaitUntilMs && l.status === "listening"
                        ? Math.max(0, Math.ceil((l.awaitUntilMs - nowTs) / 1000))
                        : 0;
                    return (
                      <tr key={l.id} className="border-t align-top">
                        <Td>{new Date(l.timestamp).toLocaleString()}</Td>
                        <Td>{l.user}</Td>
                        <Td>{l.transType}</Td>
                        <Td>{l.amount}</Td>
                        <Td>{String(l.refId)}</Td>
                        <Td>
                          <a className="text-blue-600 underline break-all" href={l.requestUrl} target="_blank" rel="noreferrer">
                            {l.requestUrl}
                          </a>
                          <details className="mt-1">
                            <summary className="text-slate-500">XML</summary>
                            <pre className="text-xs font-mono whitespace-pre-wrap">{l.requestXml}</pre>
                          </details>
                        </Td>
                        <Td>
                          {l.status === "listening" && remaining > 0 && (
                            <div className="text-xs text-amber-700">Listening… {remaining}s</div>
                          )}
                          {l.status === "timeout" && !l.responseCaptured && (
                            <div className="text-xs text-slate-500">Timed out. Paste response above, then click Attach.</div>
                          )}
                          {l.status === "loaded" && !l.responseCaptured && (
                            <div className="text-xs text-slate-500">Loaded (cross-origin). Paste & Attach to store the response.</div>
                          )}
                          <pre className="text-xs font-mono whitespace-pre-wrap mt-1">
                            {l.responseCaptured || (l.status === "listening" ? "(awaiting response…)" : "(not captured)")}
                          </pre>
                        </Td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>
          )}
        </section>
      </div>
    </div>
  );
}

// ---- UI helpers ----
function LabeledInput({
  label,
  value,
  onChange,
  type = "text",
  placeholder,
  required = false,
  missing = false,
  disabled = false,
}) {
  return (
    <label className="flex flex-col gap-1">
      <span className="text-sm flex items-center gap-2">
        {label}
        {required && (
          <span className={`text-[10px] px-2 py-0.5 rounded-full ${missing ? "bg-red-100 text-red-700" : "bg-slate-100 text-slate-500"}`}>
            Required
          </span>
        )}
      </span>
      <input
        className={`px-3 py-2 rounded-xl border ${missing ? "border-red-400 ring-1 ring-red-200" : ""}`}
        type={type}
        placeholder={placeholder}
        value={value}
        aria-required={required}
        disabled={disabled}
        onChange={(e) => onChange(e.target.value)}
      />
    </label>
  );
}
function LabeledReadOnly({ label, value }) {
  return (
    <label className="flex flex-col gap-1 opacity-80">
      <span className="text-sm">{label}</span>
      <input className="px-3 py-2 rounded-xl border bg-slate-100" readOnly value={value} />
    </label>
  );
}
function LabeledSelect({ label, value, onChange, options, required = false, missing = false }) {
  return (
    <label className="flex flex-col gap-1">
      <span className="text-sm flex items-center gap-2">
        {label}
        {required && (
          <span className={`text-[10px] px-2 py-0.5 rounded-full ${missing ? "bg-red-100 text-red-700" : "bg-slate-100 text-slate-500"}`}>
            Required
          </span>
        )}
      </span>
      <select
        className={`px-3 py-2 rounded-xl border ${missing ? "border-red-400 ring-1 ring-red-200" : ""}`}
        value={value}
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map((o) => (
          <option key={o} value={o}>
            {o}
          </option>
        ))}
      </select>
    </label>
  );
}
function Th({ children }) {
  return <th className="text-left font-medium p-2">{children}</th>;
}
function Td({ children }) {
  return <td className="p-2">{children}</td>;
}

// ---- XML & CSV helpers ----
function escapeXml(str) {
  return str
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&apos;");
}
function csvEscape(s) {
  const str = String(s ?? "");
  if (/[",
]/.test(str)) {
    return '"' + str.replaceAll('"', '""') + '"';
  }
  return str;
}

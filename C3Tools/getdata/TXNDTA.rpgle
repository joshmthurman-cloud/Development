**FREE
// TXNDTA - IWS: read JOSH/C3FP3020, return JSON. V7R4 CRTBNDRPG.
// File: QSYS.LIB/JOSH.LIB/C3FP3020.FILE. Lines <= 80 chars.
ctl-opt dftactgrp(*no) actgrp(*caller) datfmt(*iso);
dcl-f C3FP3020 extfile('C3FP3020') extlib('JOSH') usage(*input) keyed;
dcl-pi *n;
  request  varchar(1000) const;
  response varchar(32700) options(*varsize);
end-pi;
dcl-ds rec likerec(C3FP3020:*input) end-ds;
dcl-s keyVal char(15) inz(*blanks);
dcl-s maxRows  int(10) inz(50);
dcl-s count    int(10) inz(0);
dcl-s haveKey  ind inz(*off);
dcl-s dateFrom char(8) inz('');
dcl-s dateTo   char(8) inz('');
dcl-s out      varchar(32700);
dcl-s s        varchar(500);
dcl-s keyStr   varchar(256);
dcl-c QUOTE    '"';
dcl-c BSLASH   '\';
// Mainline must come before procedures in RPG
clear response;
out = '';
parseRequest();
if haveKey;
  keyVal = %subst(keyStr: 1: 15);
  chain keyVal C3FP3020 rec;
  if %found(C3FP3020);
    count = 1;
    out = '{"count":1,"rows":[';
    out = out + buildOneRow();
    out = out + ']}';
  else;
    out = '{"count":0,"rows":[]}';
  endif;
else;
  keyVal = *loval;
  setll keyVal C3FP3020;
  dow 1 = 1;
    read C3FP3020 rec;
    if %eof();
      leave;
    endif;
    if not inDateRange();
      iter;
    endif;
    count = count + 1;
    if count = 1;
      out = '{"count":';
      out = out + %char(maxRows);
      out = out + ',"rows":[';
    endif;
    if count > 1;
      out = out + ',';
    endif;
    out = out + buildOneRow();
    if count >= maxRows;
      leave;
    endif;
  enddo;
  if count = 0;
    out = '{"count":0,"rows":[]}';
  else;
    s = %subst(out: 1: 10) + %char(count) + %subst(out: %scan(',': out));
    out = s + ']}';
  endif;
endif;
response = out;
return;
// Parse: MFUKEY=...&MAXROWS=n&DATEFROM=YYYYMMDD&DATETO=YYYYMMDD
dcl-proc parseRequest;
  dcl-pi *n;
  end-pi;
  dcl-s p   int(10);
  dcl-s q   int(10);
  dcl-s tok varchar(256);
  haveKey = *off;
  maxRows = 50;
  dateFrom = '';
  dateTo = '';
  s = %trim(request);
  if s = '';
    return;
  endif;
  p = 1;
  dou p > %len(s);
    q = %scan('&': s: p);
    if q = 0;
      q = %len(s) + 1;
    endif;
    tok = %subst(s: p: q - p);
    p = q + 1;
    if %scan('MFUKEY=': tok) = 1;
      keyStr = %trim(%subst(tok: 8));
      keyStr = %subst(keyStr: 1: 15);
      haveKey = (keyStr <> '');
    elseif %scan('MAXROWS=': tok) = 1;
      maxRows = %int(%trim(%subst(tok: 9)));
      if maxRows < 1;
        maxRows = 1;
      endif;
      if maxRows > 500;
        maxRows = 500;
      endif;
    elseif %scan('DATEFROM=': tok) = 1;
      dateFrom = %trim(%subst(tok: 10: 8));
    elseif %scan('DATETO=': tok) = 1;
      dateTo = %trim(%subst(tok: 8: 8));
    endif;
  enddo;
end-proc parseRequest;
// MFDATE CHAR(8) YYYYMMDD; filter by dateFrom/dateTo
dcl-proc inDateRange;
  dcl-pi *n ind;
  end-pi;
  dcl-s d char(8);
  if dateFrom = '' and dateTo = '';
    return *on;
  endif;
  d = %char(rec.MFDATE);
  d = %subst(d: 1: 8);
  if dateFrom <> '' and d < dateFrom;
    return *off;
  endif;
  if dateTo <> '' and d > dateTo;
    return *off;
  endif;
  return *on;
end-proc inDateRange;
// Initial field set: MFUKEY, MFDATE, MFTIME, MFCUST, MFMRCH, MFAMT1, MFSETA, MFRTXT
// No PCI: MFCARD, MFTRK1, MFCVV2, MFPINC
dcl-proc buildOneRow;
  dcl-pi *n varchar(4000);
  end-pi;
  dcl-s r varchar(4000);
  r = '{';
  r = r + QUOTE + 'MFUKEY' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFUKEY)) + QUOTE;
  r = r + ',' + QUOTE + 'MFDATE' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFDATE)) + QUOTE;
  r = r + ',' + QUOTE + 'MFTIME' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFTIME)) + QUOTE;
  r = r + ',' + QUOTE + 'MFCUST' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFCUST)) + QUOTE;
  r = r + ',' + QUOTE + 'MFMRCH' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFMRCH)) + QUOTE;
  r = r + ',' + QUOTE + 'MFAMT1' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFAMT1)) + QUOTE;
  r = r + ',' + QUOTE + 'MFSETA' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFSETA)) + QUOTE;
  r = r + ',' + QUOTE + 'MFRTXT' + QUOTE + ':' + QUOTE + jsonEsc(%char(rec.MFRTXT)) + QUOTE;
  r = r + '}';
  return r;
end-proc buildOneRow;
// Escape " and \; control chars -> space
dcl-proc jsonEsc;
  dcl-pi *n varchar(1000);
    in varchar(1000) value;
  end-pi;
  dcl-s out varchar(2000) inz('');
  dcl-s c   char(1);
  dcl-s i   int(10);
  for i = 1 to %len(%trimr(in));
    c = %subst(in: i: 1);
    select;
      when c = QUOTE;
        out = out + BSLASH + QUOTE;
      when c = BSLASH;
        out = out + BSLASH + BSLASH;
      when c < ' ';
        out = out + ' ';
      other;
        out = out + c;
    endsl;
  endfor;
  return out;
end-proc jsonEsc;
